Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з дисципліни «Архітектура програмного забезпечення»
Тема роботи: «Програмна система для завчасного виявлення захворювання у дітей у пологовому будинку»

Виконав 	
ст. гр. ПЗПІ-21-1                                                                                             Ричко О. С.

Керівник: 
доц. каф. ПІ	         	        Лещинський В. О.

Робота захищена на оцінку                                                      	        _______________

Комісія:
доц. каф. ПІ	         	        Лещинський В. О.
доц. каф. ПІ	         		  Лещинська І. О.
ст. викл. каф. ПІ	         		     Сокорчук І. П.


	Харків 2024
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Ричку Олексію Сергійовичу
1.	Тема роботи: «Програмна система для завчасного виявлення захворювання у дітей у пологовому будинку»	
2.	Термін узгодження завдання курсової роботи «1» квітня 2024 р.
3.	Термін здачі студентом закінченої роботи «16» червня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
реалізація трьох компонентів (Back-end, Front-end, IoT), унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, локалізація, забезпечення конфіденційності та адміністрування системи	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram	
КАЛЕНДАРНИЙ ПЛАН

Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проєкту	31.03.24	
2	Проєктування програмного
проєкту	30.04.24	
3	Кодування програмного проєкту	20.05.24	
4	Оформлення пояснювальної
записки	31.05.24	
5	Захист курсової роботи	08.06.24	

Дата видачі завдання «1» квітня 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)
Завдання прийняв до виконання
ст. гр. ПЗПІ-21-1	                 Ричко О. С.
(підпис)


 
РЕФЕРАТ

	Пояснювальна записка до курсової роботи: 82 с., 28 рис., 2 табл. 4 додатки, 5 джерел.
	АДМІНІСТРАТОР, БАТЬКИ, ДАТЧИК, ДІТИ, КЛІЄНТ, КОРИСТУВАЧ, ЛІКАР, НОВОНАРОДЖЕНИЙ, ПРОГРАМНА СИСТЕМА.
	Об’єктом дослідження є галузь завчасного виявляння захворювання у новонароджених дітей, а саме створення програмної системи для завчасного виявлення захворювання у дітей у пологовому будинку з можливістю за допомогою технологій IoT.
	Метою курсової роботи є створення програмної системи, яка дозволяє налаштувати та автоматизувати догляд та виявлення захворювань у новонароджених. Програмна система дозволить користувачам передивлятись дані дитини, слідкувати за її аналізами, отримувати сповіщення в разі незвичайного стану.
Методи розробки базуються на технології ASP.NET Web API та мові програмування C#, бази даних на ядрі PostgreSQL, інтерфейс базується на технології Next.Js, що є фреймворком для React та  мови програмування TypeScript, інтеграції IoT-пристроїв з програмним забезпеченням.
У результаті роботи було розроблену програмну систему для завчасного виявлення захворювання у дітей у пологовому будинку. Програмна система складається з серверної частини для обробки даних, веб-додатку для клієнтів та серверу для інтеграції з IoT-пристроями.
ЗМІСТ
	

Вступ	7
1 Аналіз предметної області	8
1.1 Бізнес-вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес-цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2 Концепція рішення	12
1.2.1 Окреселення концепції	12
1.2.2 Головна функціональність	13
1.2.3 Припущення та залежності	15
1.3 Рамки та обмеження проєкту	16
1.3.1 Рамки первинного випуску	16
1.3.2 Рамки наступних випусків	19
1.3.3 Обмеження та винятки	20
1.4 Бізнес-контекст	21
1.4.1 Профілі зацікавлених сторін	21
1.4.2 Пріорітети проєкту	22
1.4.3 Робоче середовище	23
2 Постановка задачі	25
3 Проєктування бази даних	26
3.1 Побудова ER-діаграми	26
3.2 Побудова логічної моделі бази даних на основі ER-діаграми	28
4 Архітектура програмної системи	34
4.1 Архітектура серверної частини	34
4.2 Архітектура ІоТ-частини	38
4.3 Архітектура клієнтської частини	42
5 Опис програмної системи	48
5.1 Виклик і завантаження	48
5.2 Призначення і логічна структура	49
5.3 Опис програмної реалізації	51
Висновки	59
Перелік джерел посилання	60
Додаток А Результат перевірки на плагіат	61
Додаток Б Програмний код серверної частини	62
Додаток В Програмний код ІоТ пристрою	71
Додаток Г Програмний код клієнтської частини	75

 
ВСТУП


	Сучасні пологові будинки стикаються з викликом виявлення можливих захворювань у новонароджених на ранніх стадіях. Це особливо важливо, оскільки швидке виявлення та лікування можуть значно підвищити шанси на одужання та зменшити потенційні ускладнення для малюка. Забезпечення швидкого доступу до точної медичної інформації є критично важливим для забезпечення ефективного медичного обслуговування в перший місяць життя.
Потрібні нові підходи і технології, що дозволять вчасно виявляти різноманітні аномалії та ризики для здоров'я, зокрема використання передових методів аналізу даних.
Наша програмна система пропонує інноваційний підхід до автоматизації цього процесу. Вона використовує нові обладнання, що дозволяють рано виявляти аномалії в стані здоров'я малюка, а також сповістити лікарів та батьків.
Головна мета проєкту - підвищити якість медичного обслуговування дітей після народження і зменшити ризики ускладнень завдяки впровадженню сучасних технологій.
 
АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості


Аналоги:
¬ –		GE Healthcare: Ця компанія пропонує широкий спектр перинатальних моніторів, які дозволяють відстежувати стан плода під час пологів та післяпологового періоду. Їхні системи оснащені передовими технологіями, які забезпечують точні та надійні дані про серцебиття плода, рухи, рівень кисню та інші важливі параметри. Однак, їхні системи можуть бути дорогими та складними у використанні.
–		Philips: Ця компанія також пропонує широкий спектр перинатальних моніторів, які відомі своєю простотою використання та точністю даних. Їхні системи часто використовуються в пологових будинках та клініках по всьому світу. Однак, деякі моделі можуть мати обмежені можливості моніторингу та інтеграції з іншими медичними системами.
–		SonoScape: Ця китайська компанія пропонує доступні перинатальні монітори, які поєднують в собі простоту використання та надійність. Їхні системи стають все більш популярними в країнах, що розвиваються, де бюджет на охорону здоров'я може бути обмеженим. Проте, деякі моделі можуть мати менш просунуті функції.
Даний продукт спрямований на ринок пологових будинків та медичних установ, які спеціалізуються на догляді за новонародженими. Основний спосіб монетизації полягає у співпраці з цими закладами, надаючи їм зручний та ефективний інструмент для раннього виявлення захворювань у дітей.


1.1.2 Бізнес-цілі та критерії успіху


БЦ-1: Зручний моніторинг для покращення досвіду користувачів у пологових будинках:
БЦ-1.1: Розробити інтерфейс для збору медичних даних дітей в реальному часі (електрокардіограма, насиченість киснем, температура тіла та рівень рухової активності) та інтеграція з іншими системами.
БЦ-1.2: Розробити інтуїтивний веб- та мобільний інтерфейс для пологових будинків та родичів з легким доступом до даних, управління датчиками та звітами.

КУ-1: Досягти 90% задоволеності користувачів:
КУ-1.1: Проводити щоквартальні опитування медичного персоналу та батьків новонароджених для збору відгуків про систему..

БЦ-2: Підвищити ефективність роботи медиків:
БЦ-2.1: Оптимізація обробки даних для швидкого та точного аналізу медичних метрик новонароджених.
БЦ-2.2: Поліпшити користувацький доступ для родичів з доступом до комплексних даних дитини, покращуючи досвід користувача.

КУ-2: Успішність використання продукту
КУ-2.1: Скорочення часу обробки даних та підвищення їх ефективності.
КУ-2.2: Інтеграція з існуючими клініками (не менше 60%).
БЦ-3: Розширення користувацької бази:
БЦ-3.1: Збільшення користувачів на 20% за 3 місяці завдяки стратегічній маркетинговій кампанії, спрямовану на пологові будинки та батьків новонароджених.

КУ-3: Ефективність та успішність системи
КУ-3.1: Точність аналізу та передачі даних користувачів (не менше 90%).
КУ-3.2: Безперебійна робота системи сповіщення можливого захворювання стану дитин.


1.1.3 Потреби клієнтів або ринку


	П-1: Моніторинг життєво важливих показників новонароджених. Пологові будинки та родичі потребують можливості цілодобового відстеження електрокардіограми, рівня насиченості киснем, температури тіла та рівня рухової активності новонароджених. Це дає їм комплексне уявлення про стан їхнього здоров'я та дозволяє їм вчасно виявляти будь-які проблеми.
П-2: Інтеграція та інтуїтивний інтерфейс. Користувачі шукають систему, яка легко інтегрується з IoT-пристроями та пологовими будинками. Інтерфейс користувача повинен бути простим та зрозумілим, щоб медичиний персонал та родичі могли легко керувати медичними даними та розуміти стан здоров'я дитини.
П-3: Система екстреного оповіщення. Пологові будинки потребують системи, яка автоматично оповіщає лікарів у випадках можливих захворювань новонароджених. Це гарантує, що пацієнти отримають негайну медичну допомогу.
П-4: Співпраця між медичним персоналом та батьками. Система повинна сприяти ефективній комунікації між медичним персоналом та батьками новонароджених. Це дає можливість батькам бути в курсі стану здоров'я своєї дитини.
П-5: Аналітика та дослідження. Система повинна генерувати аналітичні дані на основі медичних даних новонароджених. Це дає цінну інформацію для досліджень та покращення методів раннього виявлення захворювань.


1.1.4 Бізнес-ризики


Конкуренція: існує загроза конкуренції з боку інших компаній, які розробляють подібні системи для раннього виявлення захворювань у новонароджених.
Дії: Розробика унікальну пропозицію продажу, яка підкреслює переваги та інновації системи.
Технічні проблеми: несправності датчиків або відмови системи можуть призвести до неточного моніторингу стану новонароджених.
Дії: використовувати високоякісні датчики та компоненти від надійних постачальників, проводити ретельні тести та перевірки системи на всіх етапах розробки, забезпечити надійну систему резервного копіювання.
Низька прийнятність ринку: недостатня обізнаність про продукт або низька зацікавленість з боку медичних установ можуть обмежити його прийняття.
Дії: провести активну маркетингову кампанію, спрямовану на медичні установи та батьків новонароджених, співпрацювати з ключовими лідерами думок та медичними організаціями, продемонструвати ефективність системи за допомогою клінічних досліджень та реальних випадків використання.


1.2 Концепція рішення
1.2.1 Окреселення концепції


Концепція передбачає створення інноваційної програмної системи для раннього виявлення захворювань у новонароджених, яка трансформує підхід до моніторингу та управління станом здоров'я дітей у пологових будинках. Мета полягає в тому, щоб розробити високоточну, доступну та просту у використанні систему, яка дозволить медичним працівникам пологових будинків проводити безперервний моніторинг стану новонароджених, щоб вчасно виявляти ознаки можливих захворювань.
Після впровадження системи моніторингу очікується зміна підходу до надання медичних послуг. Система дозволить медичному персоналу пологових будинків виявляти ознаки можливих захворювань у новонароджених на ранніх стадіях, коли лікування є більш ефективним. Завдяки ранньому виявленню та лікуванню захворювань продукт допоможе знизити рівень дитячої смертності та покращити здоров'я новонароджених. Також, батьки новонароджених зможуть бути впевнені, що їхні діти отримують найкращий можливий догляд, завдяки безперервному моніторингу та своєчасному реагуванню на будь-які проблеми зі здоров'ям.
Ця концепція ґрунтується на реальних потребах пологових будинків та батьків, враховуючи технічні можливості та економічні фактори. Метою є створення продукту, який допоможе змінити парадигму раннього виявлення захворювань у новонароджених, зробивши його більш доступним, надійним та зручним для всіх зацікавлених сторін.


1.2.2 Головна функціональність 


MF-1: Реєстрація та авторизація користувачів у мобільному додатку та веб-інтерфейсі.
MF-2: Збір та моніторинг медичних даних, включаючи електрокардіограму, рівень насиченості киснем, температуру тіла та рівня рухової активності новонароджених. Дані з датчиків будуть моніторитися цілодобово, дозволяючи медичному персоналу вчасно виявляти будь-які проблеми зі здоров'ям дитини.
MF-3: Додавання новонароджених до системи за допомогою адміністративної панелі. Під час додавання можна буде налаштувати датчики для збору необхідних медичних даних.
MF-4: Автоматичне сповіщення медичного персоналу полового будинку у випадку можливого захворювання або критичного стану, отриманих з даних, зібраних датчиками. Це дозволить медичним працівникам негайно відреагувати та надати дитині необхідну допомогу.
MF-5: Перегляд даних стану новонароджених, аналізів, збережених у адміністративній панелі веб-сайту, за допомогою мобільного додатку.
MF-6: Можливість медичного персоналу управляти датчиками, які підключені до новонароджених, через адміністративну панель веб-сайту.
MF-7: Віддалений перегляд та аналіз історичних медичних даних новонароджених через мобільний додаток або веб-інтерфейс.
MF-8: Цілодобова технічна підтримки користувачам для вирішення будь-яких технічних питань та надання порад щодо використання системи.

1.2.3 Припущення та залежності


Припущення:
1.	Припускається, що система повинна мати доступ до необхідних датчиків для збору медичних даних новонароджених, таких як електрокардіограма, рівень насиченості киснем, температура тіла та рівень рухової активності новонароджених. Ці датчики повинні бути сумісними з системою та відповідати вимогам щодо точності та надійності.
2.	Припускається, що користувачі матимуть доступ до мобільних пристроїв, необхідних для використання мобільного додатку системи. Ці пристрої повинні мати можливість підключатися до Інтернету та мати сумісні з системою операційні системи.
3. Припускається, що стабільниий доступ до Інтернету буде забезпечений для передачі даних між датчиками на сервери.
4.	Припускається, що медичний персонал пологових будинків матиме необхідну кваліфікацію для інтерпретації даних, що збираються системою, та вжиття відповідних дій у разі виявлення критичних показників або відхилень від норми, що призводять до майбутніх захворювань.
Залежності:
1. Залежність від надійності та точності датчиків, що поставляються сторонніми постачальниками. Якість та надійність датчиків безпосередньо впливатимуть на точність даних, що збираються, та на ефективність роботи системи.
2. Залежність від стійкості мобільних мереж та доступу до Інтернету для безперебійної передачі даних з датчиків на сервери.
3. Залежність від постійного розвитку технологій, таких як датчики, мобільні пристрої, програмне забезпечення та Інтернет. Необхідно буде регулярно оновлювати систему, щоб вона залишалася сумісною з новими технологіями та відповідала мінливим потребам користувачів.
4. Залежність від надійних методів забезпечення конфіденційності та безпеки медичних даних новонароджених. Необхідно буде впровадити суворі заходи безпеки, щоб захистити дані від несанкціонованого доступу, розголошення та використання.

1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Веб-інтерфейс:
– 	Реєстрація та авторизація: медичний персонал пологових будинків матиме можливість реєструватися та авторизуватися в системі за допомогою веб-інтерфейсу.
–	Перегляд даних про стан дитин: користувачі веб-інтерфейсу зможуть переглядати дані про стан новонароджених в режимі реального часу, включаючи електрокардіограму, рівень насиченості киснем, температуру тіла та рівень рухової активності новонароджених.
–	Додавання пацієнтів: адміністратор системи матиме можливість додавати новонароджених дітей до системи.
–	Відстеження змін у стані дитини: користувачі зможуть відстежувати динаміку змін стану новонароджених, щоб виявляти будь-які тенденції або відхилення від норми.
–	Отримання сповіщень про нездоровий стан новонароджених: у випадку виявлення критичного стану або відхилень від норми, що призводять до майбутніх захворювань дитини система автоматично оповістить медичний персонал пологового будинку через веб-інтерфейс та батьків через мобільний додаток.
–	Додавання аналізів пацієнта: адміністратор системи матиме можливість додавати результати аналізів новонароджених до їхніх медичних профілів.
IoT-функціональність:
–	Підключення датчиків до пацієнтів: датчики, що підключаються до тіла новонароджених, будуть збирати медичні дані в режимі реального часу та передавати їх до системи.
–	Автоматичне оповіщення: у випадку виявлення критичного стану або відхилень від норми, що призводять до майбутніх захворювань дитини, система автоматично оповістить медичний персонал пологового будинку через веб-інтерфейс та батьків через мобільний додаток.
MF-1: Реєстрація та авторизація користувачів.
Користувачі зможуть легко створити акаунт та увійти до системи через веб-інтерфейс або мобільний додаток, використовуючи власний логін та пароль. Це забезпечить безпечний доступ до даних про стан новонароджених.
MF-2: Збір та моніторинг медичних даних.
Користувачі веб-інтерфейсу та мобільного додатку зможуть переглядати актуальні дані про стан новонароджених, включаючи електрокардіограму, рівень насиченості киснем, температуру тіла та рівень рухової активності новонароджених, які збираються датчиками. Це дозволить медичному персоналу пологових будинків постійно відстежувати стан новонароджених та своєчасно виявляти будь-які проблеми зі здоров'ям.
MF-3: Додавання пацієнта до системи.
Адміністратор системи зможе додавати нових новонароджених до системи через адміністративний інтерфейс. Він також зможе налаштовувати параметри датчиків, необхідних для збору медичних даних кожної дитини.
MF-4: Автоматичне сповіщення.
Користувачі веб-інтерфейсу та мобільного додатку зможуть отримувати сповіщення у випадку критичних змін у медичних показниках новонароджених, які можуть вказувати на необхідність медичної уваги. Це дозволить медичному персоналу швидко реагувати на критичні ситуації та покращити результати лікування новонароджених або запобігти можливі захворювання.
MF-5: Перегляд даних стану дитини, збережених у адміністративній панелі веб-сайту, за допомогою мобільного додатку та веб-інтерфейсу.
Користувачі мобільного додатку та веб-інтерфейсу зможуть переглядати актуальні дані про стан новонароджених.


1.3.2 Рамки наступних випусків


Веб-інтерфейс:
–	Відстеження записів та аналізів історичних даних про аналізи дитини: користувачі зможуть переглядати та аналізувати історичні результати аналізів новонароджених, щоб краще розуміти їхній стан здоров'я протягом певного періоду часу.
–	Управління датчиками дитини: адміністратор системи матиме можливість керувати датчиками, підключеними до новонароджених, через веб-інтерфейс. Це дозволить їм перевіряти стан датчиків, калібрувати їх та за необхідності міняти.
–	Відповіді на запити технічної підтримки: адміністратор системи матиме можливість відповідати на запити користувачів щодо технічної підтримки через веб-інтерфейс.
MF-6: Управління датчиками дітей.
Адміністратор системи матиме можливість керувати датчиками, підключеними до новонароджених, через веб-інтерфейс.
MF-7: Дистанційний перегляд та аналіз історичних медичних даних дитини.
Користувачі веб-інтерфейсу та мобільного додатку зможуть переглядати та аналізувати історичні медичні дані новонароджених.
MF-8: Надання технічної підтримки користувачам:
Система буде надавати користувачам допомогу з технічними питаннями та поради щодо використання системи. Користувачі зможуть звернутися до служби технічної підтримки через веб-інтерфейс або мобільний додаток.


1.3.3 Обмеження та винятки


–	Обмеження втрати зв'язку з медичними датчиками: система покладається на постійний зв'язок з медичними датчиками для збору та передачі даних про стан новонароджених. У випадку втрати зв'язку з датчиками система може тимчасово втрачати доступ до деяких медичних показників, що може призвести до затримки в постановці діагнозу або наданні лікування.
– 	Обмеження неможливості вимірювання певних показників: деякі аспекти стану новонароджених, такі як психічний стан, біль або інші суб'єктивні відчуття, неможливо виміряти за допомогою доступних датчиків. У таких випадках система може не надати повну картину стану новонародженого, що може призвести до неправильного діагнозу або неадекватного лікування.
–	Залежність від Інтернету: Для використання мобільного додатку та веб-інтерфейсу системи необхідний доступ до Інтернету. Відсутність доступу до Інтернету може призвести до неможливості віддаленого моніторингу стану новонароджених, неможливості отримання сповіщень про зміни в стані новонароджених, неможливості керування датчиками та налаштуваннями системи.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


	На таблиці 1.1 описані профілі зацікавлених сторін:
Таблиця 1.1 – Профілі зацікавлених сторін проекту

Зацікавлена сторона	Головна
цінність	
Ставлення	
Головний інтерес	
Обмеження
Пологові будинки	Швидкий доступ до медичної інформації 	Стійке, допоки продукт буде сумісний з теперішньою системою виявлення захворювань у дітей	Підвищення продуктивності медичного персоналу та оптимізація лікування та виявлення захворювань дітей	Наявність доступу до мережі Інтернет або електромережі
Медичний персонал та аналітики 	Вчасний та точний моніторинг стану новонароджених для запобігання ускладнень та швидкої реакції	Орієнтоване на зручніть, позитивне	Зниження ризику серйозних медичних ускладнень та підвищення якості надання медичних послуг	Доступність датчиків для медичних даних
Батьки дітей	Швидкий доступ до стану дитини	Позитивне, орієнтоване на зручність	Слідкування за станом дитини	Доступ до Інтернету
Інвестори	Фінансова віддача, зростання доходів, реінвестиції	Орієнтоване на прибуток	Зростання ринку, перевага над конкурентами	Очікування ROI (повернення інвестицій), ринкові ризики


1.4.2 Пріорітети проєкту


	На таблиці 1.2 наведені пріорітети проєкту:
Таблиця 1.2 – Пріоритети проекту
Показник	Виконання (етапи)	Обмеження
(граничні значення)	Ступінь свободи
(допустимий діапазон)

Розклад/план робіт		Продукт має бути випущеним приблизно до 05.06.2024	Можливе відхилення від графіку на 1-3 місяці
Функціональність			100% функціоналу має працювати на релізі 1.0
Ціна		~42 000 гривень	Допусти ме відхилення на 15%
Персонал		Максимальний розмір команди це 1 розробник та адміністратор	
Якість			100% всіх наявних данних з датчиків повинні бути вірними 


1.4.3 Робоче середовище


Програмна система буде обслуговувати користувачів з різних країн, тому безперебійний доступ є дуже важливим компонентом робочого середовища. Хмарні сервіси Amazon Web Service мають таку функціональність, їх й було використано.
Для серверної частини буде використано мову програмування C# [1], яка забезпечує надійність, безпечність та швидкість та технологію ASP.NET [2] Web API, що забезпечує високу ефективніть та швидкість додатку.
В якості бази даних буде використано ядро PostgreSQL [3], завдяки швидкості, надійності, шифруванню даних та відповідності вимогам GDPR. Завдяки бібліотеці Entity Framework Core, яка є ORM, буде здійснено доступ до взаємодії з базою даних.
Для розробки веб-застосунку буде використано фреймворк Next.Js [4], який є фреймворком для React.js, та мову програмування TypeScript [5].
Для розробки IoT пристрою буде використано мову програмування C# та технологію AoT.
Для забезпечення безпеки, буде використано протокол HTTPS для передачі даних з шифруванням, а також використання JWT як метод для авторизації та аутентифікації, що додає додатковий шар захисту.
 
2	ПОСТАНОВКА ЗАДАЧІ


Відповідно до попереднього аналізу предметної області, завданням курсової роботи було поставлено створення програмної системи для завчасного виявлення захворювання у дітей у пологовому будинку.
База даних повинна включати інформацію про: користувачів, дітей, батьків, датчиків, даних з датчиків, аналізів та попереджень.
Для клієнта має бути реалізований такий функціонал:
–	Реєстрація та вхід в систему;
–	Перегляд та редагування своїх даних, таких як ПІБ та інформація про контракт;
–	Перегляд інформації про дітей;
–	Перегляд статистики даних з датчиків дітей.
Для адміністратора системи має бути реалізований наступний функціонал:
–	Вхід в систему;
–	Перегляд, створення, редагування та видалення користувачів;
–	Перегляд, створення, редагування та видалення датчиків;
–	Перегляд, створення, редагування та видалення налаштувань датчиків;
–	Створення та імпорт копій даних системи.
Також, пограмна система має підтримувати локалізацію та інтернаціоналізацю, а саме: кодові таблиці символів, обчислення дати й часу, формат дати й часу, місцевий час, універсальний час, метричні й імперські одиниці вимірювання, порядок сортування тексту, різні напрями введення тексту.
3	ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


Для проєктування бази даних було розроблено ER-модель даних (див. рис. 3.1). Вона складається з 8 таблиць: користувачі, новонароджені, батьки, датчики, аналізи, медичні дані, сповіщення та налаштування датчиків.
 
Рисунок 3.1 – ER-діаграма проєкту
На діаграмі можна побачити такі зв’язки:
	¬−	Користувач –> Новонароджений. Один до багатьох. Кожен користувач може мати багато новонароджених, але кожен новонароджений пов'язаний лише з одним користувачем.
	−	Користувач –> Батько. Один до багатьох. Кожен користувач може мати багато батьків, але кожен батько пов'язаний лише з одним користувачем.
	−	Новонароджений –> Батько. Багато до багатьох. Кожен новонароджений може мати багато батьків, а також кожен батько може мати багато новонароджених. Цей зв'язок представлений через проміжну таблицю UserParent.
	−	Датчик –> Налаштування датчика. Один до одного. Кожен датчик має лише один набір налаштувань, а також кожні налаштування датчика пов'язані лише з одним датчиком.
	−	Датчик –> Запис медичних даних. Один до багатьох. Кожен датчик може мати багато записів медичних даних, але кожен запис медичних даних пов'язаний лише з одним датчиком.
	−	Датчик –> Запис медичних даних. Один до багатьох. Кожен датчик може мати багато записів медичних даних, але кожен запис медичних даних пов'язаний лише з одним датчиком.
	−	Новонароджений –> Аналіз. Один до багатьох. Кожен новонароджений може мати багато аналізів, але кожен аналіз пов'язаний лише з одним новонародженим.
	−	Датчик –> Сповіщення. Один до багатьох. Кожен датчик може мати багато сповіщень, але кожне сповіщення пов'язане лише з одним датчиком.
3.2 Побудова логічної моделі бази даних на основі ER-діаграми


	Для забезпечення нормалізації бази даних, варто усунути зв’язки «багато-до-багатьох» між сутностями Новонароджений та Батько. Для цього створимо проміжну сутність Батько_Дитина.
	Отже, у логічній моделі бази даних будуть представлені такі сутності:
−	Користувачі (User);
−	Діти (Newborn);
−	Батьки (Parent);
−	Датчики (Sensor);
−	Аналізи (Analysis);
−	Сповіщення (Alerts);
−	Медичні дані (Medical Data);
−	Налаштування датчику (SensorSettings);
−	Батьки_діти (Parent_Newborn);
Створимо таблицю користувачів (User). Вона буде містити у собі такі атрибути: Id (первинний ключ), Username, Password, Salt, Email, Role.
Перевіримо таблицю User на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю дітей (Newborn). Вона буде містити у собі такі атрибути: Id (первинний ключ), UserId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею User), Name, DateOfBirth, Gender.
Перевіримо таблицю Newborn на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю батьків (Parent). Вона буде містити у собі такі атрибути: Id (первинний ключ), UserId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею User), Name, ContractInfo.
Перевіримо таблицю Parent на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю датчиків (Sensor). Вона буде містити у собі такі атрибути: Id (первинний ключ), NewbornId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Newborn), SensorType, SensorSettingsId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею SensorSettings).
Перевіримо таблицю Sensor на відповідність нормалізації:

–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю аналізів (Analysis). Вона буде містити у собі такі атрибути: Id (первинний ключ), NewbornId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Newborn), Time, DoctorResult.
Перевіримо таблицю Analysis на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю медичних даних (MedicalData). Вона буде містити у собі такі атрибути: Id (первинний ключ), SensorId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Sensor), TimeSaved, SensorData.
Перевіримо таблицю MedicalData на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю сповіщень (Alert). Вона буде містити у собі такі атрибути: Id (первинний ключ), SensorId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Sensor), TimeAlerted, AlertMessage, AlertType.
Перевіримо таблицю Alert на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю налаштувань датчику (SensorSettings). Вона буде містити у собі такі атрибути: Id (первинний ключ), HighCriticalThreshold, LowCriticalThreshold, HighEdgeThreshold, LowEdgeThreshold, SamplingFrequency, IsActive.
Перевіримо таблицю SensorSettings на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю батьки-діти (Parent_Newborn). Вона буде містити у собі такі атрибути: NewbornId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Newborn), ParentId (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Parent).
Перевіримо таблицю Parent_Newborn на відповідність нормалізації:
–	усі атрибути атомарні: містять лише одне значення, а не множину;
–	відсутність повторюваності даних;
–	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
За результатами проектування таблиць та зв’язків майбутньої бази даних, було отримано її логічну схему, яка задовольняє першій, другій і третій нормальним формам (див. рис. 3.2).
 
Рисунок 3.2 – Логічна схема бази даних

Оскільки всі таблиці в логічній схемі бази даних знаходяться в третій нормальній формі, можна зробити висновок, що база даних загалом відповідає третій нормальній формі.
 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Система включає в себе три типи користувачів: клієнт, адміністратор та зовнішні пристрої. Кожна група користувачів використовує веб-інтерфейс і мобільний застосунок для взаємодії з системою. Веб-інтерфейс дозволяє адміністраторам ефективно керувати мережею, медичному персоналу - отримувати доступ до медичної інформації. Мобільний застосунок полегшує взаємодію між батьками та системою. IoT-прилади використовуються для збору даних і покращення функціональності системи.
Основними потребами клієнтів є: перегляд медичних даних дитини, збереження медичних аналізів дитини, можливість аналізу медичних даних дитини, можливість виявити можливі захворювання або критичний стан новородженого, можливість отримання сповіщення щодо зміни стану або критичного стану дитини, отримання статистики даних з датчиків, зміна своїх даних та даних дитини.
Основними потребами адміністратора є: можливість перегляду та створення, редагування користувачів системи, можливість створення датчиків в системі, можливість налаштування датчиків в системі, можливість створення, редагування та видалення аналізів дитини, можливість створення резервних копій даних системи та їхній імпорт в систему.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).
 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи
Для написання серверної частини системи було обрано мову програмування C# з використанням технології ASP.NET Core Web API, дозволяючи писати швидкий та продуктивний код.
У якості бази даних використано PostgreSQL, до якої здійснюється доступ з серверного застосунку за допомогою технології Entity Framework Core, дуже зручної бібліотеки, яка дозволяє мати взаємодію з базою даних через об’єкти. 
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).
 
Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи
Для демонстрації та тестування API використовується OpenApi Swagger, зручний інструмент для перегляду та тестування API, покращує якість та зручність розробки. Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, який захищає дані під час їх передачі.
Для шифрування паролів та створення токенів авторизації використовується бібліотека System.Security.Cryptography для хешування паролів та JWT (Json Web Tokens) для створення токенів, що створює потужний та безпечний механізм управління доступом користувачів. Для передачі та отримання даних використовується принцип REST API.
Для маршрутизації запитів система використовує API контролери. Вони розбивають програму на логічні компоненти, кожен з яких відповідає за обробку певного типу запитів або користувацьких дій. Це спрощує управління кодом та дозволяє легко розширювати функціональність.
Розроблений серверний застосунок побудований за принципами трьох-шарової архітектури, яка складається з: Core, Abstraction, Services та Controllers.
В архітектуру також були додані інтерцептори (Interceptors), які перехоплюють запити та можуть їх блокувати, не допускаючи непідходящі по різним причинам запити до контролера. Система використовує три інтерцептори: AdminRoleInterceptor, DoctorRoleInterceptor та SensorRoleInterceptor. Також, використовуюється інтерцептор Authorize. Архітектура серверного застосунку представлена на діаграмі пакетів (див. рис. 4.3).
 
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи

Приклади коду серверної частини наведено в додатку Б. Таким чином, були визначені технології та архітектура серверної частини програмної системи.


4.2 Архітектура ІоТ-частини


IoT частина системи взаємодіє з двома типами користувачів: лікарі та дитини. Пряма взаємодія з користувачами відбувається за допомогою монітора, на який виводяться збережені сенсором дані, його ліміти та частоту збору даних.
Взаємодію користувача з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4).
 
Рисунок 4.4 – Діаграма прецедентів ІоТ частини програмної системи
	Для демонстрації функціональних можливостей IoT частини системи було вирішено реалізувати програмний код мовою C#, оптимізований для відповідності апаратним обмеженням IoT пристроїв завдяки компіляції у режимі Native AoT. Програма використовує консольний інтерфейс (CLI) для виведення інформації та бібліотеку System.Net.Http для надсилання даних у форматі JSON.
Програма призначена для тривалого функціонування на сервері, де зберігається таблиця з ідентифікаторами, які можна присвоювати IoT пристроям. Це дозволяє безперервно записувати показники датчика протягом тривалого часу. Програму легко перенести на реальні IoT пристрої. Також, код програми було написано з найменшою можливою кількістю рядків для оптимізації під пристрої з обмеженими ресурсами.
Для розробки IoT частини системи було обрано мову програмування C# завдяки її CLR компоненту .NET 8, який компілює код. Для створення та відправлення HTTP-запитів використовується бібліотека System.Net.Http, а для серіалізації та десеріалізації об'єктів застосовуються бібліотеки System.Text.Json та Newtonsoft.Json. Для більш детальної візуалізації використаних технологій було створено діаграму пакетів (див. рис. 4.5).
 
Рисунок 4.5 -  Діаграма пакетів ІоТ частини програмної системи
	Для запуску додатку, потрібно налаштувати пристрій, увімкнути його та підключити до WiFi. Якщо пристрій новий, його потрібно зареєструвати в системі. Після цього, пристрій починає надсилати нові дані на сервер. На основі описаної взаємодії, було побудовано діаграму взаємодії (див. рис. 4.6).
 
Рисунок 4.6 – Діаграма взаємодії ІоТ частини програмної системи
	Також, було створено діаграму діяльності (див. рис. 4.7).
 
Рисунок 4.7 – Діаграма діяльності ІоТ частини програмної системи
	Таким чином, за допомогою діаграм пакетів, станів та діяльності були визначені основні технології та архітектура системи. 
Приклади коду IoT-частини системи було наведено в додатку В.1.
4.3 Архітектура клієнтської частини


	В розробленій системі можна виділити два типи акторів: адміністратор та батько.
	До потреб батьків відносяться: 
•	можливість реєстрації;
•	можливість авторизації;
•	можливість отримання та зміни власної інформації;
•	можливість отримання інформації про дітей;
•	можливість отримання останніх даних за всіма типами датчиків у дитини;
•	можливість отримання статистики щодо показників дитини.
До потреб адміністратора відносяться:
•	можливість додавання, редагування, видалення користувачів;
•	можливість додавання, редагування, датчиків;
•	можливість додавання, редагування, видалення налаштувань датчиків;
•	можливість створення та завантаження резервних копій даних системи.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.8).
 
Рисунок 4.8 – діаграма прецедентів клієнтської частини програмної системи
Для написання клієнтської частини системи було обрано мову програмування TypeScript з використанням фреймворку Next.Js, фреймворку для React, що забезпечує високу швидкість роботи додатку, зручність у розробці та тестуванні за рахунок статичної типізації TypeScript та підходу розділення компонентів. Також, Next.Js надає власну, вже реалізовану систему навігації по сайту зі зручним використанням в будь якому місці коду, має власний компілятор.
Для реалізації елементів інтерфейсу було використано бібліотеку Material UI, бібліотеки з попередньо стилізованими компонентами, що ґрунтуються на рекомендаціях Google з дизайну.
Для реалізації локалізації інтерфейсу було використано бібліотеки i18next, next-i18n-router, що легко інтегруються до проекту, мають конфігурацію та реалізують зручну локалізацію.
Для виконання асинхронних запитів на сервер було axios, який дозволяє зручно взаємодіяти з HTTP-запитами.
Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.9).
 
Рисунок 4.9 – Діаграма пакетів клієнтської частини програмної системи
У розробленій клієнтській частині проєкту використовується Feature-Sliced архітектура, яка визначає структуру проєкту за допомогою шарів. Шари включають зрізи, які в свою чергу включають сегменти. Шари – це каталоги верхнього рівня застосунку. У проєкті є 4 шари: app, components, hooks, utils. Шар app визначає основні сторінки додатку (сегменти) з використанням влаштованого навігатора від Next.Js, наприклад, сторінка login. Шар components визначає основні компоненти системи. Шар hooks визначає основні об’єкти хуків, які використовуються для отримання доступу до станів системи. Шар utils визначає основні компоненти утіліти проєкту, наприклад, створення axios.
Для кращого уявлення архітектури системи було створено діаграму компонентів (див. рис. 4.10).
 
Рисунок 4.10 – Діаграма компонентів клієнтської частини програмної системи
Взаємодія з програмною системою починається з авторизації  - або входу в уже існуючий акаунт, або його створення. Також, створити акаунт адміна неможливо. Після авторизації, згідно ролі користувача, взаємодія розділяється на клієнтську та адміністраторську.
Як батько, клієнт має можливість подивитись свої дані та змінити їх, встановивши ім’я та інформацію про контракт. Також, батьку доступна інформація про його дітей. Вони можут побачити ім’я дитини, дату народження, а також подивитись їхні дані. Для цього, батьку потрібно перейти на сторінку інформації дитини, на якій буде статистика останніх даних обраних датчиків у вигляді графіку. Також, батько зможе побачити всі дані з всіх датчиків дитини, включаючи дату створення.
Адміністратор має можливість виконувати керування даними системи з панелі адміністратора. Він може зберегти та завантажити дані системи, керувати користувачами системи, керувати датчиками системи, а також керувати налаштуваннями датчиків.
Для кращого уявлення про взаємодію користувачів з клієнтською частиною системи було розроблено діаграму взаємодії (див. рис. 4.11).
 
Рисунок 4.11 – Діаграма взаємодії клієнтської частини програмної системи

Приклади коду клієнтської частини системи представлено в додатку Г. 
Таким чином, було визначено архітектуру, технології програмної системи за допомогою діаграми прецедентів, пакетів, компонентів та взаємодії.
 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


	Для того, щоб запустити програму, потрібно завантажити архів з кодом програми та разархівувати його. Також, необхідно встановити останню версію ядра PostgreSQL з офіційного сайту проудку, бо програма використовує його.
	Для того, щоб налаштувати з’єднання програми з базою даних, потрібно створити файл appsettings.json за шляхом “apz-pzpi-21-1-rychko-oleksii/Task2/apz-pzpi-21-1-rychko-oleksii-task2/Backend” та за допомогою будь-якого текстового редактору вказати вміст рядку, виділеного жовтим на рисунку 5.1, вказавши інформацію для входу до бази даних. Також, необхідно вказати секретний ключ JWT, який буде використовуватись у підписанні токенів, він виділений зеленим.
 
Рисунок 5.1 – Налаштування системи у файлі appsettings.json
	Далі потрібно запустити серверну та клієнтську частини системи. Для цього можна використовувати JetBrains Rider, яку необхідно завантажити з офіційного сайту продукту. Наступним кроком буде відкриття файлу Backend.sln у папці “apz-pzpi-21-1-rychko-oleksii-task2”, а також натиснути “CTRL + F5”, щоб запустити проєкт не у режимі дебагу.
	Запуск ІоТ частини відбувається тим же шляхом, як запуск серверної частини. Потрібно створити файл settings.json за шляхом “apz-pzpi-21-1-rychko-oleksii/Task3/apz-pzpi-21-1-rychko-oleksii-task3/StarOfLifeIoT” та за допомогою будь-якого текстового редактору вказати вміст рядку, виділеного зеленим на рисунку 5.2, вказавши посилання на хост серверної частини.
 
Рисунок 5.2 – Налаштування ІоТ-пристрою у файлі settings.json
	Для запуску клієнтської частини, потрібно відкрити папку “apz-pzpi-21-1-rychko-oleksii/Task4/apz-pzpi-21-1-rychko-oleksii-task4/ui” у будь якому середовищі розробки, такі як Visual Studio Code або JetBrains Webstorm. Після цього, потрібно написати “npm install” у терміналі, щоб у проєкті встановились залежності, вказані у package.json. Після цього, потрібно написати “npm run dev”, що запустить проєкт.


5.2 Призначення і логічна структура


	Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
–	авторизація та реєстрація;
–	профіль;
–	діти;
–	дані системи;
–	користувачі системи;
–	датчики системи;
–	налаштування датчиків системи;
Модуль «Авторизація та реєстрація» містить у собі функціонал для входу в систему та реєстрації нового аккаунту. Реєстрація дає користувачу можливість створити новий запис у базі даних та завдяки ньому входити в систему, за допомогою логіну та пароля. Для того, щоб увійти як адмін, потрібно створити його в базі даних.
Модуль «Профіль» містить у собі функціонал перегляду та зміни інформації власного профілю, таких як ім’я, прізвище, а також інформацію про контракт з пологовим будинком.
Модуль «Діти» містить у собі функціонал перегляду дітей батьків, а також перегляд статистики даних з усіх датчиків, які під’єднані до дитини.
Модуль «Дані системи» є адміністраторським та містить у собі функціонал для експорту та імпорту даних системи.
Модуль «Користувачі системи» є адміністраторським та містить у собі функціонал для додавання, редагування та видалення користувачів системи.
Модуль «Датчики системи» є адміністраторським та містить у собі функціонал для додавання, редагування та видалення датчиків системи.
Модуль «Налаштування датчиків системи» є адміністраторським та містить у собі функціонал для додавання, редагування та видалення налаштувань датчиків системи.


5.3 Опис програмної реалізації


	Перше, що зустрічає користувача – це головна сторінка (див. рис. 5.3). З неї можно перейти на сторінки авторизації та реєстрації, а також змінити мову сайту у правому верхньому куті. До вибору доступні дві мови – українська на англійська (див. рис. 5.4).
 
Рисунок 5.3 – Головна сторінка сайту
 
Рисунок 5.4 – Головна сторінка сайту українською
	На сторінці реєстрації (див. рис. 5.5) можна зареєструвати новий акаунт. Для цього потрібно ввести логін та пароль нового користувача. 
 
Рисунок 5.5 – Сторінка реєстрації
	На сторінці входу у вже існуючий акаунт потрібно ввести логін та пароль, щоб увійти в акаунт (див. рис. 5.6).
 
Рисунок 5.6 – Сторінка авторизації в систему

	Після входу користувач може зайти на сторінку профілю, натиснувши «Get started». Після цього відкриється сторінка профілю, де буде зображено інформацію користувача та його дітей (див. рис. 5.7).
 
Рисунок 5.7 – Сторінка профілю користувача
	Користувач може змінити свої дані, потрібно натиснути «Edit Profile». Після цього, відкриється сторінка зміни інформації профілю (див. рис. 5.8).
 
Рисунок 5.8 – Сторінка зміни інформації профілю
	Також, користувач може подивитись інформацію про його дітей, натиснувши на кнопку «View statistics» відповідної дитини. На цій сторінці знаходиться графік даних обраних датчиків дитини, а також останні дані датчиків (див. рис. 5.9).
 
Рисунок 5.9 – Сторінка інформації дітей
	Далі розглянемо сторінку адміністратора. Після того, як адміністратор увійде в систему під своїм логіном та паролем, йому потрібно ввести “/admin” в пошукову строку та перейти на цю сторінку. На ній буде адміністративна панель (див. рис. 5.10).
 
Рисунок 5.10 – Адміністративна панель сайту
	Адміністратор має можливість створити резервну копію даних та завантажити її, для цього потрібно перейти на сторінку створення резервних копій (див. рис. 5.11). Кнопка «Save Backup» зберігає дані, а кнопка «Download Backup» завантажує копію у zip-архіві, в якому будуть .xlsx файли.
 
Рисунок 5.11 – Сторінка створення резервних копій даних
	Також, на адміністративній панелі є можливість керувати користувачами (див. рис. 5.12).
 
Рисунок 5.12 – Керування користувачами системи
	Для додавання користувача, адміністратору потрібно ввести його логін, пароль, пошту та роль. Після цього, потрібно натиснути «Add new user», тоді новий користувач буде створений. Для того, щоб редагувати його, потрібно натиснути «Edit User», що відкриє сторінку редагування користувача (див. рис. 5.13).
 
Рисунок 5.13 – Редагування користувача
	Для видалення користувача, потрібно натиснути «Delete».
На адміністративній панелі присутня можливість керувати датчиками (див. рис. 5.14).
 
Рисунок 5.14 – Керування датчиками системи
	Для додавання датчику, адміністратору потрібно ввести ідентифіактор дитини, ідентифікатор налаштувань та тип датчику. Після цього, потрібно натиснути «Add new sensor», тоді новий датчик буде створений. Для того, щоб редагувати його, потрібно натиснути «Edit sensor», що відкриє сторінку редагування датчику (див. рис. 5.15).
 
Рисунок 5.15 – Редагування датчику
	Для видалення датчику, потрібно натиснути «Delete».
Також, на адміністративній панелі присутня можливість керувати налаштуваннями датчиків (див. рис. 5.16).
 
Рисунок 5.16 – Керування налаштуваннями датчиків системи
	Для додавання налаштування датчику, адміністратору потрібно ввести нижній критичний ліміт, верхній критичний ліміт, нижній доступний ліміт, верхній доступний ліміт, частоту та вибрати, чи буде сенсор активним. Після цього, потрібно натиснути «Add new sensor settings», тоді нові налаштування будуть створений. Для того, щоб редагувати його, потрібно натиснути «Edit sensor settings», що відкриє сторінку редагування датчику (див. рис. 5.17).

 
Рисунок 5.17 – Редагування налаштування датчику
	Для видалення налаштування, потрібно натиснути «Delete».
	Таким чином, було описано можливості взаємодії користувача з розробленою
програмною системою. Запис результатів функціонального тестування доступний за посиланням: https://youtu.be/1FZ5exgZcKs (дата звернення: 17.06.2024)
 
ВИСНОВКИ


	У результаті виконаної роботи було розроблено програмну систему предметної області «Завчасне виявлення захворювання у дітей у пологовому будинку».
	У процесі розробки було проанализовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, ІоТ та клієнтської частин програмної системи, а реалізовано її за допомогою ASP.NET Web API та Next.Js.
	Розроблена програмна система дозволяє користувачам слідкувати за здоров’ям своєї дитини. Вона забезпечує реєстрацію та авторизацію користувачів, керування профілю. Користувачі можуть дивитись інформацію та статистику про їх дітей. Система забезпечує моніторинг здоров’я дитини у реальному часі, а також створює сповіщення щодо зміни стану дитини. Крім того, в системі присутнє адміністрування. Адміністратор має можливість керувати користувачами, датчиками, налаштуваннями датчиків, а також створювати та завантажувати резервні копії даних.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Бондарєв В.М. Об'єктно-орієнтоване програмування на С #. Навчальний посібник / В. М. Бондарєв. - Харків: СМІТ, 2009р. - 221 с. (дата звернення: 16.06.2024).
2. 	ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 16.06.2024)
3.	PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL:
https://www.postgresql.org/docs/16/index.html (дата звернення: 16.06.2024)
4.	Next.Js Documentation. URL: https://nextjs.org/docs (дата звернення: 16.06.2024)
5.	Typescript documentation. URL: https://www.typescriptlang.org/docs/handbook/intro.html
(дата звернення: 16.06.2024)
 
ДОДАТОК А
Результат перевірки на плагіат
 
Рисунок А.1 – Результат перевірки на плагіат
ДОДАТОК Б
Програмний код серверної частини

	Б.1 Код основного файлу для роботи сервера Program.cs:

1	using System.Text;
2	using Backend.Abstraction.Services;
3	using Backend.Core;
4	using Backend.Core.Attributes;
5	using Backend.Core.Middlewares;
6	using Backend.Services;
7	using Microsoft.AspNetCore.Authentication.JwtBearer;
8	using Microsoft.EntityFrameworkCore;
9	using Microsoft.IdentityModel.Tokens;
10	using Microsoft.OpenApi.Models;
11	
12	var builder = WebApplication.CreateBuilder(args);
13	
14	builder.Services.AddControllers();
15	builder.Services.AddEndpointsApiExplorer();
16	builder.Services.AddSwaggerGen(c =>
17	{
18	    c.SwaggerDoc("v1", new OpenApiInfo { Title = "Star Of Life api", Version = "v1" });
19	    
20	    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
21	    {
22	        Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",
23	        Name = "Authorization",
24	        In = ParameterLocation.Header,
25	        Type = SecuritySchemeType.ApiKey
26	    });
27	
28	    c.AddSecurityRequirement(new OpenApiSecurityRequirement
29	    {
30	        {
31	            new OpenApiSecurityScheme
32	            {
33	                Reference = new OpenApiReference
34	                {
35	                    Type = ReferenceType.SecurityScheme,
36	                    Id = "Bearer"
37	                }
38	            },
39	            new string[] { }
40	        }
41	    });
42	});
43	
44	builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =>
45	{
46	    options.TokenValidationParameters = new TokenValidationParameters
47	    {
48	        ValidateIssuerSigningKey = true,
49	        ValidateLifetime = true,
50	        ValidateIssuer = false,
51	        ValidateAudience = false,
52	        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8
53	            .GetBytes(builder.Configuration.GetSection("Jwt:Secret").Value)),
54	    };
55	});
56	
57	builder.Services.AddDbContext<StarOfLifeContext>(options =>
58	{
59	    options.UseNpgsql(builder.Configuration.GetConnectionString("Default"));
60	});
61	builder.Services.AddSingleton<IJwtService, JwtService>();
62	builder.Services.Configure<JwtOptions>(builder.Configuration.GetSection("Jwt"));
63	
64	builder.Services.AddScoped<AdminRoleInterceptorAttribute>();
65	builder.Services.AddScoped<DoctorRoleInterceptorAttribute>();
66	builder.Services.AddScoped<SensorRoleInterceptorAttribute>();
67	
68	builder.Services.AddScoped<IUserService, UserService>();
69	builder.Services.AddScoped<IBackupService, BackupService>();
70	builder.Services.AddScoped<INewbornService, NewbornService>();
71	builder.Services.AddScoped<IParentService, ParentService>();
72	builder.Services.AddScoped<ISensorService, SensorService>();
73	builder.Services.AddScoped<ISensorSettingsService, SensorSettingsService>();
74	builder.Services.AddScoped<IMedicalDataService, MedicalDataService>();
75	builder.Services.AddScoped<IAnalysisService, AnalysisService>();
76	builder.Services.AddScoped<IAlertService, AlertService>();
77	builder.Services.AddScoped<ISensorDataService, SensorDataService>();
78	
79	builder.Services.AddCors(options =>
80	{
81	    options.AddPolicy("AllowFrontend",
82	        builder =>
83	        {
84	            builder.WithOrigins("http://localhost:3000")
85	                .AllowAnyHeader()
86	                .AllowAnyMethod();
87	        });
88	});
89	
90	var app = builder.Build();
91	
92	app.UseCors("AllowFrontend");
93	
94	if (app.Environment.IsDevelopment())
95	{
96	    app.UseSwagger();   
97	    app.UseSwaggerUI();
98	}
99	
100	app.UseHttpsRedirection();
101	app.UseAuthentication();
102	app.UseAuthorization();
103	
104	app.MapControllers();
105	
106	app.UseMiddleware<JwtMiddleware>();
107	
108	app.Run();
	
Б.2 Код сервісу для роботи з даними датчиків
1	public class SensorDataService : ISensorDataService
2	{
3	    private readonly StarOfLifeContext _context;
4	
5	    public SensorDataService(StarOfLifeContext context)
6	    {
7	        _context = context;
8	    }
9	
10	    public async Task<Dictionary<SensorType, double>> GetAverageSensorDataAsync()
11	    {
12	        var medicalDatas = await _context.MedicalDatas
13	            .Include(md => md.Sensor)
14	            .ToListAsync();
15	        
16	        var averageData = new Dictionary<SensorType, double>();
17	        var count = new Dictionary<SensorType, int>();
18	
19	        foreach (var medicalData in medicalDatas)
20	        {
21	            var sensorType = medicalData.Sensor.SensorType;
22	            
23	            if (!averageData.ContainsKey(sensorType))
24	            {
25	                averageData[sensorType] = 0;
26	                count[sensorType] = 0;
27	            }
28	
29	            averageData[sensorType] += medicalData.SensorData;
30	            count[sensorType]++;
31	        }
32	
33	        foreach (var sensorType in averageData.Keys.ToList())
34	        {
35	            if (count.TryGetValue(sensorType, out var sensorCount) && sensorCount > 0)
36	            {
37	                averageData[sensorType] /= sensorCount;
38	            }
39	        }
40	
41	        return averageData;
42	    }
43	}

	Б.3 Код сервісу для аутентифікації
1	public class JwtService: IJwtService
2	{
3	    private readonly IConfiguration _configuration;
4	
5	    public JwtService(IConfiguration configuration)
6	    {
7	        _configuration = configuration;
8	    }
9	
10	    public string GenerateToken(int userId, Role role)
11	    {
12	        var claims = new List<Claim>
13	        {
14	            new (ClaimTypes.NameIdentifier, userId.ToString()),
15	            new (ClaimTypes.Role, role.ToString())
16	        };
17	
18	        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(
19	            _configuration.GetSection("Jwt:Secret").Value));
20	        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha512Signature);
21	        var token = new JwtSecurityToken(
22	            claims: claims,
23	            expires: DateTime.Now.AddDays(1),
24	            signingCredentials: credentials);
25	
26	        var jwt = new JwtSecurityTokenHandler().WriteToken(token);
27	        return jwt;
28	    }
29	}

	Б.4 Код сервісу для створення резервних копій даних 
1	public class BackupService: IBackupService
2	{
3	    private readonly StarOfLifeContext _context;
4	
5	    public BackupService(StarOfLifeContext context)
6	    {
7	        _context = context;
8	    }
9	
10	    public async Task SaveToCsv(string directoryPath)
11	    {
12	        Directory.CreateDirectory(directoryPath);
13	        var entityTypes = _context.Model.GetEntityTypes();
14	
15	        foreach (var entityType in entityTypes)
16	        {
17	            var entityName = entityType.ClrType.Name;
18	            var filePath = Path.Combine(directoryPath, $"{entityName}.csv");
19	            
20	            var dbSetProperty = _context.GetType().GetProperty(entityName + "s");
21	            if (dbSetProperty == null) continue;
22	            
23	            var dbSet = dbSetProperty.GetValue(_context);
24	            var queryable = dbSet as IQueryable<object>;
25	            if (queryable == null) return;
26	
27	            var entities = await queryable.ToListAsync();
28	
29	            using var writer = new StreamWriter(filePath);
30	            using var csv = new CsvWriter(writer, CultureInfo.InvariantCulture);
31	            await csv.WriteRecordsAsync(entities);
32	        }
33	    }
34	
35	    public async Task RestoreFromCsv(string directoryPath)
36	    {
37	        var entityTypes = _context.Model.GetEntityTypes();
38	
39	        foreach (var entityType in entityTypes)
40	        {
41	            var entityName = entityType.ClrType.Name;
42	            var filePath = Path.Combine(directoryPath, $"{entityName}.csv");
43	
44	            if (!File.Exists(filePath)) continue;
45	
46	            var dbSetProperty = _context.GetType().GetProperty(entityName + "s");
47	            if (dbSetProperty == null) continue;
48	
49	            var dbSet = dbSetProperty.GetValue(_context);
50	            
51	            using var reader = new StreamReader(filePath);
52	            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
53	            
54	            var entityListType = typeof(List<>).MakeGenericType(entityType.ClrType);
55	            var entities = (IList)Activator.CreateInstance(entityListType);
56	
57	            var records = csv.GetRecords(entityType.ClrType);
58	            foreach (var record in records)
59	            {
60	                entities.Add(record);
61	            }
62	            
63	            var addRangeMethod = dbSet.GetType().GetMethod("AddRange", new[] { typeof(IEnumerable<>).MakeGenericType(entityType.ClrType) });
64	            if (addRangeMethod != null)
65	            {
66	                addRangeMethod.Invoke(dbSet, new object[] { entities });
67	            }
68	            
69	            await _context.SaveChangesAsync();
70	        }
71	    }
72	
73	    public async Task<byte[]> DownloadAsZip(string directoryPath)
74	    {
75	        await SaveToCsv(directoryPath);
76	
77	        using var memoryStream = new MemoryStream();
78	        using (var zipOutputStream = new ZipOutputStream(memoryStream))
79	        {
80	            zipOutputStream.SetLevel(3);
81	
82	            var csvFiles = Directory.GetFiles(directoryPath, "*.csv");
83	            foreach (var filePath in csvFiles)
84	            {
85	                var entry = new ZipEntry(Path.GetFileName(filePath))
86	                {
87	                    DateTime = DateTime.Now,
88	                    IsUnicodeText = true
89	                };
90	                zipOutputStream.PutNextEntry(entry);
91	
92	                using var fileStream = File.OpenRead(filePath);
93	                fileStream.CopyTo(zipOutputStream);
94	                zipOutputStream.CloseEntry();
95	            }
96	        }
97	
98	        return memoryStream.ToArray();
99	    }
100	}

 
ДОДАТОК В
Програмний код ІоТ пристрою
	В.1 Стартовий файл програми
1	using System;
2	using System.IO;
3	using System.Text;
4	using System.Text.Json;
5	using System.Threading.Tasks;
6	using StarOfLifeIoT.Types;
7	
8	namespace StarOfLifeIoT
9	{
10	    internal class Program
11	    {
12	        public static async Task Main(string[] args)
13	        {
14	            var jsonString = File.ReadAllText("settings.json");
15	            
16	            var settings = JsonSerializer.Deserialize<Settings>(jsonString);
17	            
18	            var sensor = new Sensor(settings.Url, settings.LoginEndpoint, settings.SensorSettingsEndpoint, settings.MedicalDataEndpoint);
19	
20	            Console.WriteLine("Enter username: ");
21	            var username = Console.ReadLine();
22	            
23	            Console.WriteLine("Enter password: ");
24	            var password = GetHiddenConsoleInput();
25	
26	            var loginDto = new LoginDto
27	            {
28	                Username = username,
29	                Password = password
30	            };
31	            
32	            var ventricularRepolarization = 110;
33	            
34	            await sensor.Login(loginDto);
35	            
36	            while (true)
37	            {
38	                var randNum = 5 - new Random().Next(0, 10);
39	                ventricularRepolarization += randNum;
40	
41	                var medicalDataDto = new MedicalDataDto
42	                {
43	                    SensorData = ventricularRepolarization,
44	                    SensorId = settings.SensorId,
45	                    TimeSaved = DateTime.UtcNow
46	                };
47	
48	                var config = await sensor.GetSensorSettings(settings.SensorSettingsId);
49	
50	                await sensor.SaveData(medicalDataDto, settings.SensorSettingsId);
51	
52	                await Task.Delay(config?.SamplingFrequency ?? 1000);
53	            }
54	        }
55	        
56	        private static string GetHiddenConsoleInput()
57	        {
58	            StringBuilder input = new StringBuilder();
59	            while (true)
60	            {
61	                var key = Console.ReadKey(true);
62	                if (key.Key == ConsoleKey.Enter) break;
63	                if (key.Key == ConsoleKey.Backspace && input.Length > 0) input.Remove(input.Length - 1, 1);
64	                else if (key.Key != ConsoleKey.Backspace) input.Append(key.KeyChar);
65	            }
66	            return input.ToString();
67	        }
68	    }
69	}

В.2 Код файлу для відправлення запитів
1	public class Sensor
2	    {
3	        private readonly HttpClient _client;
4	        private readonly string _loginEndpoint;
5	        private readonly string _sensorSettingsEndpoint;
6	        private readonly string _medicalDataEndpoint;
7	
8	        public Sensor(string url, string loginEndpoint, string sensorSettingsEndpoint, string medicalDataEndpoint)
9	        {
10	            _client = new HttpClient
11	            {
12	                BaseAddress = new Uri(url)
13	            };
14	            _loginEndpoint = loginEndpoint;
15	            _sensorSettingsEndpoint = sensorSettingsEndpoint;
16	            _medicalDataEndpoint = medicalDataEndpoint;
17	        }
18	
19	        public async Task Login(LoginDto dto)
20	        {
21	            string jsonBody = JsonConvert.SerializeObject(dto);
22	            var content = new StringContent(jsonBody, Encoding.UTF8, "application/json");
23	
24	            var loginResponse = await _client.PostAsync(_loginEndpoint, content);
25	            
26	            loginResponse.EnsureSuccessStatusCode();
27	            
28	            var responseBody = await loginResponse.Content.ReadAsStringAsync();
29	            
30	            _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", responseBody);
31	        }
32	
33	        public async Task SaveData(MedicalDataDto dto, int sensorSettingsId)
34	        {
35	            string jsonBody = JsonConvert.SerializeObject(dto);
36	
37	            var config = await GetSensorSettings(sensorSettingsId);
38	
39	            if (config != null && config.IsActive)
40	            {
41	                var content = new StringContent(jsonBody, Encoding.UTF8, "application/json");
42	
43	                var response = await _client.PostAsync(_medicalDataEndpoint, content);
44	                
45	                response.EnsureSuccessStatusCode();
46	                
47	                Console.WriteLine("Saved data successfully"); 
48	                Console.WriteLine($"Sensor: {dto.SensorId}, data: {dto.SensorData}, sensor low critical threshold: {config.LowCriticalThreshold}, sensor high critical threshold: {config.HighCriticalThreshold}, sensor high edge threshold: {config.HighEdgeThreshold}, sensor low edge threshold: {config.LowEdgeThreshold}");
49	            }
50	        }
51	
52	        public async Task<SensorSettings> GetSensorSettings(int sensorSettingsId)
53	        {
54	            var configResponse = await _client.GetAsync(_sensorSettingsEndpoint + sensorSettingsId);
55	            
56	            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
57	            
58	            configResponse.EnsureSuccessStatusCode();
59	
60	            return JsonSerializer.Deserialize<SensorSettings>(await configResponse.Content.ReadAsStringAsync(), options);
61	        }
62	    }

ДОДАТОК Г
Програмний код клієнтської частини

	Г.1 Код сторінки інформації дитини
1	"use client";
2	
3	import React, { useEffect, useState } from "react";
4	import {
5	  Box,
6	  Select,
7	  VStack,
8	  Heading,
9	  Spinner,
10	  useToast,
11	  Button,
12	  Table,
13	  Tbody,
14	  Td,
15	  Th,
16	  Thead,
17	  Tr,
18	} from "@chakra-ui/react";
19	import {
20	  LineChart,
21	  Line,
22	  XAxis,
23	  YAxis,
24	  CartesianGrid,
25	  Tooltip,
26	  Legend,
27	  ResponsiveContainer,
28	} from "recharts";
29	import axiosInstance from "@/utils/axios-instance";
30	import moment from "moment";
31	import { SensorType } from "@/components/management/sensor-management";
32	import { useTranslation } from "react-i18next";
33	import router from "next/router";
34	
35	interface MedicalData {
36	  timeSaved: string;
37	  data: number;
38	  sensor: number;
39	}
40	
41	const NewbornStatistics = ({ params }: { params: { id: number } }) => {
42	  const [allData, setAllData] = useState<MedicalData[]>([]);
43	  const [filteredData, setFilteredData] = useState<MedicalData[]>([]);
44	  const [sensorTypes, setSensorTypes] = useState<number[]>([]);
45	  const [selectedSensor, setSelectedSensor] = useState("");
46	  const toast = useToast();
47	
48	  const { t } = useTranslation();
49	
50	  useEffect(() => {
51	    const fetchNewbornData = async () => {
52	      try {
53	        const response = await axiosInstance.get(`/Newborn/data/${params.id}`);
54	        const data = response.data.map((d: MedicalData) => ({
55	          ...d,
56	          timeSaved: moment(d.timeSaved).format("MMMM Do YYYY, h:mm:ss a"),
57	        })) as MedicalData[];
58	
59	        const sensors = [...new Set(data.map((d: MedicalData) => d.sensor))];
60	        setSensorTypes(sensors);
61	
62	        setAllData(data);
63	        if (sensors.length > 0) {
64	          setSelectedSensor(SensorType.ElectroCardiogram.toString());
65	          setFilteredData(
66	            data.filter((d: MedicalData) => d.sensor === sensors[0])
67	          );
68	        }
69	      } catch (error) {
70	        console.error("Error fetching newborn data:", error);
71	        toast({
72	          title: t("error"),
73	          status: "error",
74	          duration: 5000,
75	        });
76	      }
77	    };
78	
79	    fetchNewbornData();
80	  }, [params.id, t, toast]);
81	
82	  const handleSensorChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
83	    const sensor = SensorType[event.target.value as any];
84	    setSelectedSensor(sensor);
85	    setFilteredData(allData.filter((d: MedicalData) => d.sensor === +sensor));
86	  };
87	
88	  return (
89	    <VStack spacing={4} align="stretch">
90	      <Box>
91	        <Heading as="h2" size="lg" mb={4}>
92	          {t("newborn-statistics")}
93	        </Heading>
94	        <Select onChange={handleSensorChange} mb={4}>
95	          {Object.keys(SensorType)
96	            .filter((key: string) => !isNaN(+key))
97	            .filter((key) => sensorTypes.includes(+key))
98	            .map((key: string) => (
99	              <option key={key} value={SensorType[+key]}>
100	                {SensorType[+key]}
101	              </option>
102	            ))}
103	        </Select>
104	        {filteredData.length > 0 ? (
105	          <ResponsiveContainer width="100%" height={400}>
106	            <LineChart data={filteredData}>
107	              <CartesianGrid strokeDasharray="3 3" />
108	              <XAxis dataKey="timeSaved" />
109	              <YAxis />
110	              <Tooltip />
111	              <Legend />
112	              <Line type="monotone" dataKey="data" stroke="#8884d8" />
113	            </LineChart>
114	          </ResponsiveContainer>
115	        ) : (
116	          <Spinner />
117	        )}
118	      </Box>
119	      <Table variant="simple">
120	        <Thead>
121	          <Tr>
122	            <Th>{t("sensor")}</Th>
123	            <Th>{t("data")}</Th>
124	            <Th>{t("date")}</Th>
125	          </Tr>
126	        </Thead>
127	        <Tbody>
128	          {allData.map((data, i) => (
129	            <Tr key={i}>
130	              <Td>{SensorType[data.sensor]}</Td>
131	              <Td>{data.data}</Td>
132	              <Td>{data.timeSaved}</Td>
133	            </Tr>
134	          ))}
135	        </Tbody>
136	      </Table>
137	    </VStack>
138	  );
139	};
140	
141	export default NewbornStatistics;

Г.2 Код адміністративної панелі
1	"use client";
2	
3	import React from "react";
4	import {
5	  Box,
6	  Heading,
7	  VStack,
8	  Link as ChakraLink,
9	  Button,
10	} from "@chakra-ui/react";
11	import { useAdminAuth } from "@/hooks/use-admin-auth";
12	import UserManagement from "@/components/management/user-management";
13	import SensorManagement from "@/components/management/sensor-management";
14	import SensorSettingsManagement from "@/components/management/sensor-settings-management";
15	import Link from "next/link";
16	import { useTranslation } from "react-i18next";
17	
18	const AdminPanel = () => {
19	  useAdminAuth();
20	
21	  const { t } = useTranslation();
22	
23	  return (
24	    <Box p={8}>
25	      <VStack spacing={4} align="stretch">
26	        <Heading as="h1" size="xl" textAlign="center">
27	          {t("admin-panel")}
28	        </Heading>
29	        <ChakraLink as={Link} href="/admin/backup">
30	          <Button colorScheme="blue" mb={4}>
31	            {t("backup-database")}
32	          </Button>
33	        </ChakraLink>
34	        <Heading as="h1" size="xl" textAlign="center">
35	          {t("users")}
36	        </Heading>
37	        <UserManagement />
38	        <Heading as="h1" size="xl" textAlign="center">
39	          {t("sensors")}
40	        </Heading>
41	        <SensorManagement />
42	        <SensorSettingsManagement />
43	      </VStack>
44	    </Box>
45	  );
46	};
47	
48	export default AdminPanel;

Г.3 Код сторінки експорту даних системи
1	"use client";
2	
3	import axiosInstance from "@/utils/axios-instance";
4	import { Box, Button, useToast } from "@chakra-ui/react";
5	import { useTranslation } from "react-i18next";
6	
7	const BackupManagement = () => {
8	  const toast = useToast();
9	  const { t } = useTranslation();
10	
11	  const handleBackup = async () => {
12	    try {
13	      await axiosInstance.post("/backup/save");
14	
15	      toast({
16	        title: t("success"),
17	        status: "success",
18	        duration: 5000,
19	      });
20	    } catch (error) {
21	      console.error("Error saving backup:", error);
22	      toast({
23	        title: t("error"),
24	        status: "error",
25	        duration: 5000,
26	      });
27	    }
28	  };
29	
30	  const handleDownload = async () => {
31	    try {
32	      const response = await axiosInstance.post("/backup/download", null, {
33	        responseType: "blob",
34	      });
35	
36	      const url = window.URL.createObjectURL(new Blob([response.data]));
37	      const link = document.createElement("a");
38	      link.href = url;
39	      link.setAttribute("download", "database_backup.zip");
40	      document.body.appendChild(link);
41	      link.click();
42	      link.remove();
43	
44	      toast({
45	        title: t("success"),
46	        status: "success",
47	        duration: 5000,
48	      });
49	    } catch (error) {
50	      console.error("Error downloading backup:", error);
51	      toast({
52	        title: t("error"),
53	        status: "error",
54	        duration: 5000,
55	      });
56	    }
57	  };
58	
59	  return (
60	    <Box
61	      style={{
62	        display: "flex",
63	        justifyContent: "center",
64	        flexDirection: "column",
65	        gap: "10px",
66	      }}
67	    >
68	      <Button colorScheme="blue" onClick={handleBackup}>
69	        {t("save-backup")}
70	      </Button>
71	      <Button colorScheme="blue" onClick={handleDownload}>
72	        {t("download-backup")}
73	      </Button>
74	    </Box>
75	  );
76	};
77	
78	export default BackupManagement;
